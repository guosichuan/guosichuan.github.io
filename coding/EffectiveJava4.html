<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>第四章 类和接口 - Wiki Guosichuan</title>
    <meta name="keywords" content="simiki, wiki, python, simple"/>
    <meta name="description" content="Simiki is a simple static site generator for wiki."/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#coding">coding</a>&nbsp;&#187;&nbsp;第四章 类和接口
    <span class="updated">Updated&nbsp;
      2016-08-28 10:39
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">第四章 类和接口</div>

  <h1 id="_1">类和接口</h1>
<p>@(Java基础)[simiki]</p>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">类和接口</a><ul>
<li><a href="#_2">使类和成员的可访问性最小化</a><ul>
<li><a href="#_3">技巧</a></li>
<li><a href="#_4">成员的四种访问级别</a></li>
</ul>
</li>
<li><a href="#_5">在公有类中使用访问方法而非公有域</a></li>
<li><a href="#_6">使可变性最小化</a></li>
<li><a href="#_7">复合优先于继承</a></li>
<li><a href="#_8">接口优于抽象类</a></li>
<li><a href="#_9">常量的安置</a></li>
<li><a href="#_10">类层次优于标签类</a></li>
<li><a href="#_11">用函数对象表示策略</a></li>
<li><a href="#_12">优先考虑静态成员类</a><ul>
<li><a href="#_13">静态成员类与非静态成员类</a></li>
<li><a href="#_14">匿名类的用法</a></li>
<li><a href="#_15">局部类用的最少</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="_2">使类和成员的可访问性最小化</h2>
<h3 id="_3">技巧</h3>
<ol>
<li>如果方法是公有的，就必须<strong>永远支持它</strong>，以保持它们的兼容性。</li>
<li>子类的访问级别<strong>不允许低于超类中的访问级别</strong>，以便确保任何可使用超类的地方也都可以使用子类的实例。</li>
<li>为了测试最多可以将公有类的私有成员变成<strong>包级私有</strong>的。</li>
<li>接口中的所有方法都隐含着<strong>公有访问级别</strong>。</li>
<li><strong>实例域决不能是公有的</strong>，这会失去对这个域中的值的限制能力。如果一定要公有，必须是公有静态final不可变。</li>
<li>如果一个包级私有的顶层类（或者接口）只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的<strong>私有嵌套类</strong>。</li>
</ol>
<h3 id="_4">成员的四种访问级别</h3>
<ul>
<li><strong>私有的</strong>（private）——只有在声明该成员的顶层<strong>类内部</strong>才可以访问这个成员。</li>
<li><strong>包级私有的</strong>（package-private）——声明该成员的<strong>包内部</strong>的任何类都可以访问这个成员。（默认访问级别）</li>
<li><strong>受保护的</strong>（protected）——声明该成员的类的<strong>子类</strong>可以访问这个成员（但是有一些限制），并且，声明该成员的<strong>包内部</strong>的任何类也可以访问这个成员。</li>
<li><strong>公有的</strong>(public)——在任何地方都可以访问该成员。</li>
</ul>
<h2 id="_5">在公有类中使用访问方法而非公有域</h2>
<ul>
<li>公有域应该用<strong>私有域和公有访问方法（getter）</strong>的类代替，这样可以在方法中进行控制（最佳实践）。</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Encapsulation of data by accessor methods and mutators</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">y</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getX</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getY</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">y</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setX</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setY</span><span class="o">(</span><span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li><strong>公有类</strong>永远不应该直接暴露<strong>可变的域</strong>（不可变危害较小）;<strong>包级私有</strong>的，或者是<strong>私有嵌套</strong>类，直接暴露它的数据域并没有本质的错误。</li>
</ul>
<h2 id="_6">使可变性最小化</h2>
<ul>
<li>不可变对象比较简单，<strong>只有一种状态</strong>。</li>
<li>不可变对象不可变，所以它本质上<strong>线程安全</strong>，而且该对象及其组件是<strong>可以被共享</strong>的。</li>
<li>唯一的缺点是每个不同的值都需要一个单独的对象，这在复杂的多阶段操作当中可能会产生性能问题。解决方法就是提供<strong>可变配套类</strong>（例如String和StringBuilder），变化的工作就交给配套类解决，最终转化回不可变类即可。如果复杂的多阶段操作是<strong>可以预测</strong>的，则<strong>包级私有</strong>的可变配套类可以解决问题(BigInteger的可变配套类)；如果<strong>不可预测</strong>，则提供<strong>公有可变配套类</strong>（StringBuilder）。</li>
<li>不可变类可以拥有一个或多个<strong>非final的域</strong>，可以在第一次被请求执行这些计算的时候（例如散列值）的时候，把开销昂贵的<strong>计算结果缓存</strong>在这些域中，将来如果被再次请求同样的计算，就可以直接返回这些缓存值，因为<strong>对象内容是不可变的</strong>。</li>
<li>如果类不能是不可变的，也要<strong>尽可能地限制它的可变性</strong>，降低对象可以存在的状态数。</li>
<li>不可变类要防止子类化，子类可能破坏父类的不可变行为（?）。</li>
<li>不可变类的设计方法<ol>
<li>用所有<strong>构造器变成私有</strong>或者包级私有来防止不可变类被继承。</li>
<li>添加<strong>公有的静态工厂</strong>来代替公有的构造器，来完成<strong>构造器</strong>的工作，并方便<strong>提供缓存</strong>。</li>
</ol>
</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Immutable class - pages 76-78</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Complex</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">re</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">im</span><span class="o">;</span>
   <span class="kd">private</span> <span class="nf">Complex</span><span class="o">(</span><span class="kt">double</span> <span class="n">re</span><span class="o">,</span> <span class="kt">double</span> <span class="n">im</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Complex</span> <span class="nf">valueOf</span><span class="o">(</span><span class="kt">double</span> <span class="n">re</span><span class="o">,</span> <span class="kt">double</span> <span class="n">im</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="o">(</span><span class="n">re</span><span class="o">,</span> <span class="n">im</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Complex</span> <span class="nf">valueOfPolar</span><span class="o">(</span><span class="kt">double</span> <span class="n">r</span><span class="o">,</span> <span class="kt">double</span> <span class="n">theta</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="o">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">Math</span><span class="o">.</span><span class="na">cos</span><span class="o">(</span><span class="n">theta</span><span class="o">),</span>
                           <span class="n">r</span> <span class="o">*</span> <span class="n">Math</span><span class="o">.</span><span class="na">sin</span><span class="o">(</span><span class="n">theta</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Complex</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Complex</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Complex</span> <span class="n">ONE</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">Complex</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Complex</span> <span class="n">I</span>    <span class="o">=</span> <span class="k">new</span> <span class="n">Complex</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>

    <span class="c1">// Accessors with no corresponding mutators</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">realPart</span><span class="o">()</span>      <span class="o">{</span> <span class="k">return</span> <span class="n">re</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">imaginaryPart</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">im</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Complex</span> <span class="nf">add</span><span class="o">(</span><span class="n">Complex</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="o">(</span><span class="n">re</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span><span class="o">,</span> <span class="n">im</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Complex</span> <span class="nf">subtract</span><span class="o">(</span><span class="n">Complex</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="o">(</span><span class="n">re</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span><span class="o">,</span> <span class="n">im</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Complex</span> <span class="nf">multiply</span><span class="o">(</span><span class="n">Complex</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="o">(</span><span class="n">re</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span> <span class="o">-</span> <span class="n">im</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">,</span>
                           <span class="n">re</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span> <span class="o">+</span> <span class="n">im</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Complex</span> <span class="nf">divide</span><span class="o">(</span><span class="n">Complex</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Complex</span><span class="o">((</span><span class="n">re</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span> <span class="o">+</span> <span class="n">im</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">)</span> <span class="o">/</span> <span class="n">tmp</span><span class="o">,</span>
                           <span class="o">(</span><span class="n">im</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span> <span class="o">-</span> <span class="n">re</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">)</span> <span class="o">/</span> <span class="n">tmp</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
           <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
       <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Complex</span><span class="o">))</span>
           <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
       <span class="n">Complex</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">Complex</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>

       <span class="c1">// See page 43 to find out why we use compare instead of ==</span>
       <span class="k">return</span> <span class="n">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">re</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="na">re</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
              <span class="n">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">im</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="na">im</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

   <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">int</span> <span class="n">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">17</span> <span class="o">+</span> <span class="n">hashDouble</span><span class="o">(</span><span class="n">re</span><span class="o">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="n">hashDouble</span><span class="o">(</span><span class="n">im</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">hashDouble</span><span class="o">(</span><span class="kt">double</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">longBits</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">doubleToLongBits</span><span class="o">(</span><span class="n">re</span><span class="o">);</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="n">longBits</span> <span class="o">^</span> <span class="o">(</span><span class="n">longBits</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">32</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">String</span> <span class="n">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">re</span> <span class="o">+</span> <span class="s">&quot; + &quot;</span> <span class="o">+</span> <span class="n">im</span> <span class="o">+</span> <span class="s">&quot;i)&quot;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h2 id="_7">复合优先于继承</h2>
<ul>
<li><strong>继承打破了封装性</strong>，子类依赖于其父类中特定功能的实现细节，如果重写了父类<strong>自用的方法</strong>(如例子中，子类不知道父类中addAll是调用add方法实现的，导致逻辑混乱)，有可能导致问题。而且如果后续父类的<strong>版本迭代</strong>还有可能导致子类中出现问题。</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Broken - Inappropriate use of inheritance!</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InstrumentedHashSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// The number of attempted element insertions</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">addCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">InstrumentedHashSet</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">InstrumentedHashSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">initCap</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">initCap</span><span class="o">,</span> <span class="n">loadFactor</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addCount</span><span class="o">++;</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">addAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addCount</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAddCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">addCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">InstrumentedHashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">InstrumentedHashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="n">s</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&quot;Snap&quot;</span><span class="o">,</span> <span class="s">&quot;Crackle&quot;</span><span class="o">,</span> <span class="s">&quot;Pop&quot;</span><span class="o">));</span>    
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">getAddCount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>在新的类中增加一个私有域，它引用现有类的一个实例。这种设计被称为“<strong>复合</strong>”。新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。这被称为<strong>转发</strong>，新类中的方法被称为<strong>转发方法</strong>。</li>
</ul>
<div class="hlcode"><pre><span class="c1">//复合在继承中实现</span>
<span class="c1">// Wrapper class - uses composition in place of inheritance - Page 84</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InstrumentedSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ForwardingSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">addCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">InstrumentedSet</span><span class="o">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addCount</span><span class="o">++;</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">addAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addCount</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAddCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">addCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">InstrumentedSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">InstrumentedSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;());</span>
        <span class="n">s</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&quot;Snap&quot;</span><span class="o">,</span> <span class="s">&quot;Crackle&quot;</span><span class="o">,</span> <span class="s">&quot;Pop&quot;</span><span class="o">));</span>    
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">getAddCount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//转发在实现接口类中实现</span>
<span class="c1">// Reusable forwarding class - Page 84</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForwardingSet</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">ForwardingSet</span><span class="o">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span>               <span class="o">{</span> <span class="n">s</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>            <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">o</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span>          <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>   <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span>                 <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>      <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span>     <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>  <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span>           <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>      <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span>   <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>   <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span>
                                   <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">containsAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span>
                                   <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>      <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">removeAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span>
                                   <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">removeAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>   <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">retainAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">)</span>
                                   <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">retainAll</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>   <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">()</span>          <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>  <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">[]</span> <span class="n">toArray</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span>      <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">a</span><span class="o">);</span> <span class="o">}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span>
                                       <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>  <span class="o">}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">int</span> <span class="n">hashCode</span><span class="o">()</span>    <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span> <span class="o">}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">String</span> <span class="n">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>只有当子类真正是父类的子类型时，才适合用继承。也就是确实存在<strong>“is-a”关系</strong>的时候，类B才应该扩展类A。</li>
<li>继承机制会把父类API中的所有缺陷传播到子类中，而复合则允许设计新的API来隐藏这些缺陷。</li>
</ul>
<h2 id="_8">接口优于抽象类</h2>
<ul>
<li><strong>抽象类是有层次结构的</strong>，更新需要慎重考虑放置继承层次的位置，很容易影响到后代类的功能。而<strong>接口</strong>允许我们构造<strong>非层次结构</strong>的类型框架，只需要添加个Implements，更加灵活。</li>
<li>Java只允许<strong>单继承</strong>，但是允许同时<strong>实现多个接口</strong>。</li>
<li>抽象类允许包含<strong>方法的实现</strong>，而接口的作用只是<strong>定义类型</strong>，但是最佳实践是在需要方法实现的地方可以用接口的<strong>骨架实现类</strong>(AbstractInterface)来接管所有与接口实现相关的工作。这样便有了两种选择（抽象类只能扩展），可以扩展骨架实现类，也可以在骨架实现类不满足需求时手工实现这个接口。</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Skeletal Implementation - Page 96</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractMapEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// Primitive operations</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">K</span> <span class="nf">getKey</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">V</span> <span class="nf">getValue</span><span class="o">();</span>

    <span class="c1">// Entries in modifiable maps must override this method</span>
    <span class="kd">public</span> <span class="n">V</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// Implements the general contract of Map.Entry.equals</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,?&gt;</span> <span class="n">arg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">equals</span><span class="o">(</span><span class="n">getKey</span><span class="o">(),</span>   <span class="n">arg</span><span class="o">.</span><span class="na">getKey</span><span class="o">())</span> <span class="o">&amp;&amp;</span>
               <span class="n">equals</span><span class="o">(</span><span class="n">getValue</span><span class="o">(),</span> <span class="n">arg</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Object</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">o1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">o2</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">o1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">o2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Implements the general contract of Map.Entry.hashCode</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">int</span> <span class="n">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">hashCode</span><span class="o">(</span><span class="n">getKey</span><span class="o">())</span> <span class="o">^</span> <span class="n">hashCode</span><span class="o">(</span><span class="n">getValue</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">obj</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li><strong>抽象类演变比接口容易</strong>，所有子类都会拥有抽象类新方法的默认实现，但是接口添加新方法后，所有实现了接口的骨架类（easy），实现类(hard)都必须跟着实现该方法。</li>
</ul>
<h2 id="_9">常量的安置</h2>
<ul>
<li>常量与某个现有类或接口<strong>紧密相关</strong>，就应该放在这个类或者接口中。</li>
<li>否则，应该使用<strong>不可实例化</strong>的工具类来导出这些常量。</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Constant utility class</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PhysicalConstants</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nf">PhysicalConstants</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>  <span class="c1">// Prevents instantiation</span>

  <span class="c1">// Avogadro&#39;s number (1/mol)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">AVOGADROS_NUMBER</span>   <span class="o">=</span> <span class="mf">6.02214199e23</span><span class="o">;</span>

  <span class="c1">// Boltzmann constant (J/K)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">BOLTZMANN_CONSTANT</span> <span class="o">=</span> <span class="mf">1.3806503</span><span class="n">e</span><span class="o">-</span><span class="mi">23</span><span class="o">;</span>

  <span class="c1">// Mass of the electron (kg)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">ELECTRON_MASS</span>      <span class="o">=</span> <span class="mf">9.10938188</span><span class="n">e</span><span class="o">-</span><span class="mi">31</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>如果大量利用工具类导出常量，可以利用静态导入。</li>
</ul>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">static</span> <span class="n">com</span><span class="o">.</span><span class="na">effectivejava</span><span class="o">.</span><span class="na">science</span><span class="o">.</span><span class="na">PhysicalConstants</span><span class="o">.*</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
    <span class="kt">double</span> <span class="nf">atoms</span><span class="o">(</span><span class="kt">double</span> <span class="n">mols</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">AVOGADROS_NUMBER</span> <span class="o">*</span> <span class="n">mols</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h2 id="_10">类层次优于标签类</h2>
<ul>
<li>拥有<strong>两种甚至更多</strong>风格的实例的类，并包含表示实例风格的标签（tag）域。</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Tagged class - vastly inferior to a class hierarchy!</span>
<span class="kd">class</span> <span class="nc">Figure</span> <span class="o">{</span>
    <span class="kd">enum</span> <span class="n">Shape</span> <span class="o">{</span> <span class="n">RECTANGLE</span><span class="o">,</span> <span class="n">CIRCLE</span> <span class="o">};</span>

    <span class="c1">// Tag field - the shape of this figure</span>
    <span class="kd">final</span> <span class="n">Shape</span> <span class="n">shape</span><span class="o">;</span>

    <span class="c1">// These fields are used only if shape is RECTANGLE</span>
    <span class="kt">double</span> <span class="n">length</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">width</span><span class="o">;</span>

    <span class="c1">// This field is used only if shape is CIRCLE</span>
    <span class="kt">double</span> <span class="n">radius</span><span class="o">;</span>

    <span class="c1">// Constructor for circle</span>
    <span class="n">Figure</span><span class="o">(</span><span class="kt">double</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="na">CIRCLE</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Constructor for rectangle</span>
    <span class="n">Figure</span><span class="o">(</span><span class="kt">double</span> <span class="n">length</span><span class="o">,</span> <span class="kt">double</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="na">RECTANGLE</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">length</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">double</span> <span class="nf">area</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">switch</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nl">RECTANGLE:</span>
            <span class="k">return</span> <span class="n">length</span> <span class="o">*</span> <span class="n">width</span><span class="o">;</span>
          <span class="k">case</span> <span class="nl">CIRCLE:</span>
            <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">PI</span> <span class="o">*</span> <span class="o">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="o">);</span>
          <span class="k">default</span><span class="o">:</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>标签类过于冗长，容易出错，效率低下。应该用<strong>类层次</strong>来替代。</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Class hierarchy replacement for a tagged class</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Figure</span> <span class="o">{</span>
    <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">area</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="n">Figure</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">double</span> <span class="n">radius</span><span class="o">;</span>

    <span class="n">Circle</span><span class="o">(</span><span class="kt">double</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">;</span> <span class="o">}</span>

    <span class="kt">double</span> <span class="nf">area</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">PI</span> <span class="o">*</span> <span class="o">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">extends</span> <span class="n">Figure</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">double</span> <span class="n">length</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">double</span> <span class="n">width</span><span class="o">;</span>

    <span class="n">Rectangle</span><span class="o">(</span><span class="kt">double</span> <span class="n">length</span><span class="o">,</span> <span class="kt">double</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">length</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">width</span>  <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">double</span> <span class="nf">area</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">length</span> <span class="o">*</span> <span class="n">width</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="n">Rectangle</span> <span class="o">{</span>
    <span class="n">Square</span><span class="o">(</span><span class="kt">double</span> <span class="n">side</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">side</span><span class="o">,</span> <span class="n">side</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h2 id="_11">用函数对象表示策略</h2>
<ul>
<li>java没有函数指针，函数指针的主要用途是实现<strong>策略模式</strong>，可以用<strong>对象</strong>引用实现与函数指针同样的功能,这个对象实例就是策略模式中的<strong>具体的策略</strong>。</li>
</ul>
<div class="hlcode"><pre><span class="kd">class</span> <span class="nc">StringLengthComparator</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span><span class="n">String</span> <span class="n">s2</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>具体策略类是<strong>无状态</strong>的，因此应该作为一个<strong>Singleton</strong>，可以节省不必要的对象创建开销；而且为了<strong>封装性</strong>更好，策略类应该是私有嵌套类；为了能给该策略单例对象取一个<strong>有意义的域名称</strong>，应该使用<strong>公有静态final</strong>修饰该成员，例如String类中的CASE_INSENSITIVE_ORDER域。又如：</li>
</ul>
<div class="hlcode"><pre><span class="kd">class</span> <span class="nc">Host</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">StrLenCmp</span> <span class="kd">implements</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;,</span> <span class="n">Serializable</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span><span class="n">String</span> <span class="n">s2</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
                <span class="o">}</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Stirng</span><span class="o">&gt;</span> <span class="n">STING_LENGTH_COMPARATOR</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StrLenCmp</span><span class="o">();</span>
        <span class="o">...</span>
<span class="o">}</span>
</pre></div>


<h2 id="_12">优先考虑静态成员类</h2>
<p><strong>嵌套类</strong>，是指被定义在另一个类的内部的类。包括四种，静态成员类，非静态成员类，匿名类，和局部类。除了第一种外，其它三种被称为<strong>内部类</strong>。</p>
<h3 id="_13">静态成员类与非静态成员类</h3>
<ul>
<li>如果嵌套类的实例可以在它外围类的实例之外<strong>独立存在</strong>，这个嵌套类就必须是<strong>静态成员类</strong>。</li>
<li>非静态成员类每个实例都包含一个<strong>额外指向外围对象的引用</strong>，因此在不需要外围类的情况下，优先使用静态成员类。</li>
</ul>
<h3 id="_14">匿名类的用法</h3>
<ul>
<li>动态创建<strong>函数对象</strong>,即策略。</li>
</ul>
<div class="hlcode"><pre><span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">stringArray</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(){</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span><span class="n">String</span> <span class="n">s2</span><span class="o">){</span>
                <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="o">}</span>
<span class="o">})</span>
</pre></div>


<ul>
<li>创建<strong>过程对象</strong>，比如Runnable,Thread或者TimerTask实例。</li>
<li><strong>静态工厂</strong>方法的内部，要返回一个接口或抽象类时。</li>
</ul>
<div class="hlcode"><pre><span class="c1">// Concrete implementation built atop skeletal implementation - Page 95</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntArrays</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">intArrayAsList</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>

        <span class="k">return</span> <span class="k">new</span> <span class="n">AbstractList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  <span class="c1">// Autoboxing (Item 5)</span>
            <span class="o">}</span>

            <span class="nd">@Override</span> <span class="kd">public</span> <span class="n">Integer</span> <span class="n">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">oldVal</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>     <span class="c1">// Auto-unboxing</span>
                <span class="k">return</span> <span class="n">oldVal</span><span class="o">;</span>  <span class="c1">// Autoboxing</span>
            <span class="o">}</span>

            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">intArrayAsList</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>

        <span class="n">Collections</span><span class="o">.</span><span class="na">shuffle</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3 id="_15">局部类用的最少</h3>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2016 Guosichuan.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2016-08-29 22:58:56</p>
      </span>
    </div>
  </body>
</html>